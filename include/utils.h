#ifndef UTILS_H
#define UTILS_H

#include <cmath>
#include <utility>
#include "Math/Vector3D.h" // XYZVector

using XYZ = ROOT::Math::XYZVector;
using Polar = ROOT::Math::Polar3DVector;
template <typename T> using Vec = std::vector<T>;
template <typename T> using Vec2 = std::vector<std::vector<T>>;

template<class T>
inline void print_pos(std::string intro, T p) {
  std::cout << intro << ": x=" << p.X() << ", y=" << p.Y() << ", z=" << p.Z() << std::endl;
}

template<class T>
inline void print_pos_4D(std::string intro, T p) {
  std::cout << intro << ": x=" << p.X() << ", y=" << p.Y() << ", z=" << p.Z() << ", t=" << p.T() << std::endl;
}

template<class T>
inline T to_degrees(T a) {
  return a*360 / (2*M_PI);
}

template<class T>
inline double local_distance(T a, T b) {
  double xd = a.X()-b.X();
  double yd = a.Y()-b.Y();
  double zd = a.Z()-b.Z();
  return TMath::Sqrt(xd*xd + yd*yd + zd*zd);
}


inline std::pair<float,float> calculate_angles_to_beamline(float x, float y, float z) {
  /*
    Simple trigonometric relationship.
    Calculates the angle between: 
    - a line with point (x,y,z) passing through the origin (0,0,0)
    - the beam line
    This is correct only if:
    1) the beamline aligns with the z direction.
    2) both lines pass through the origin
    A more generic function is required for other cases.
   */
  std::pair<float,float> p;
  p.first = std::atan( y / z ); //z vs y
  p.second = std::atan( x / z ); //z vs x
  return p;
}

inline unsigned get_index_closer_to_origin(const std::vector<XYZ>& pos, unsigned nitems) {
  float distance;
  for(unsigned i_step = 0; i_step<nitems; i_step++) {
    distance = TMath::Sqrt( pos[i_step].Mag2() );
    if(distance < TMath::Sqrt( pos[i_step+1].Mag2() ) and fabs(pos[i_step].Z()) < 10.)
      return i_step;
  }
  return nitems-1;
}

inline float distance_two_angles(float a1, float a2) {
  /*calculates the angle ("distance") between two angles,
    avoiding the boundary condition issues (the sum of two uniform
    distributions is a triangular distribution). 
    It is assumed that the angles lie between 0 and 2*pi.
  */
  return a2>=a1 ? a2 - a1 : 2*M_PI-(a1-a2);
}

inline XYZ rotate_coordinates(XYZ p, float theta, float phi) {
  using namespace std;
  XYZ res( cos(phi)*p.X() + sin(phi)*p.Z(),
	   sin(theta)*sin(phi)*p.X() + cos(theta)*p.Y() - sin(theta)*cos(phi)*p.Z(),
	   -sin(phi)*cos(theta)*p.X() + sin(theta)*p.Y() + cos(theta)*cos(phi)*p.Z() );
  return res;
}

inline XYZ translate_coordinates(XYZ p, XYZ origin) {
  /*
    Translate point 'p' relative to a new origin 'origin'.
    Translating a point by itself returns (0,0,0), i.e., it is the origin.
  */

  XYZ res( p.X() - origin.X(),
	   p.Y() - origin.Y(),
	   p.Z() - origin.Z() );
  return res;
}

inline XYZ intersect_plane_with_line(XYZ genpoint1, XYZ genpoint2,
			      XYZ intersectpoint1, XYZ intersectpoint2,
			      XYZ planepoint) {
  /*Calculate the intersection between a line, generated from 'intersectpoint1'
    and 'intersectpoint2', and a plane, perpendicular to the line generated by 
    'genpoint1' and 'genpoint2' and containing 'planepoint'.
  */

  //vector along the line perpendicular to the plane (normal to the plane)
  XYZ n = genpoint2-genpoint1;
  //vector along the intersection line
  XYZ l = intersectpoint2-intersectpoint1;
  
  //(l cross n)*d + (intersectlinepoint-planepoint) cross n = 0
  //bot intersectline1 or intersectline2 can be used
  //https://en.wikipedia.org/wiki/Line%E2%80%93plane_intersection
  float d = ( (planepoint - intersectpoint1).Dot(n) );
  d /= ( l.Dot(n) );

  //point of intersection
  XYZ intersection = intersectpoint1 + l*d;
  return intersection;
}

inline float get_y_in_line(float x, float x1, float y1, float x2, float y2) {
  /*
    Calculates the y coordinate of a point in a line defined by two points,
    given the x coordinate.
  */
  float slope = std::abs(y2-y1) / std::abs(x2-x1);
  return slope*(x-x1) + y1;
}

inline float sq(float x){
  return x*x;
}

#endif //UTILS_H
